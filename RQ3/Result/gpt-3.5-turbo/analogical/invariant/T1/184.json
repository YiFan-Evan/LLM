[{"role": "system", "content": "In the following questions, I will provide a target Python program code. The code is a program containing a loop, and the purpose of the code is indicated by its function name. Please provide a loop invariant for the i-th iteration of the loop to prove the partial correctness of the program. The loop invariant should be written in the form 'xxx_value = fun(arr[xxx]->arr[xxx])'. (Please note that your answer should only contain statements in the specified format.)(For each problem, you need to first present three related but not identical problems, along with a description of each problem and its solution. Finally, provide the answer to the original problem in the form of \"Therefore, the final answer is: \".)"}, {"role": "user", "content": "def selection_sort(arr):\n    e = 0\n    while e < len(arr):\n        z = e + 1\n        while z < len(arr):\n            if arr[z] < arr[e]:\n                temp = arr[e]\n                arr[e] = arr[z]\n                arr[z] = temp\n            z += 1\n        e += 1\n    return arr"}, {"role": "assistant", "content": "Problem 1:\nDescription: Suppose we have an array of integers, and we want to sort it using the selection sort algorithm. However, the implementation in the provided program has a bug. The inner loop iterates over the array from index `e + 1` to the end, but it doesn't find the minimum element correctly. Instead, it always swaps the first element with the current element if the current element is smaller. Modify the code to fix this bug.\nSolution: Update the inner loop to find the index of the minimum element from index `z` to the end of the array, and swap the minimum element with the element at index `e`.\n\nProblem 2:\nDescription: Suppose we have an array of strings, and we want to sort it using the selection sort algorithm. However, the implementation in the provided program doesn't handle string comparison correctly. It swaps the elements incorrectly based on the lexicographic order of the strings. Modify the code to fix this bug.\nSolution: Update the condition in the inner loop to compare the strings using the `<=` operator instead of the `<` operator.\n\nProblem 3:\nDescription: Suppose we have an array of floating-point numbers, and we want to sort it using the selection sort algorithm. However, the implementation in the provided program doesn't handle floating-point number comparison accurately due to floating-point arithmetic precision issues. It may incorrectly compare two floating-point numbers and swap them in the wrong order. Modify the code to fix this bug.\nSolution: Update the condition in the inner loop to compare the floating-point numbers using the `math.isclose()` function instead of the `<` operator. This function checks if two floating-point numbers are approximately equal within a specified tolerance.\n\nTherefore, the final answer is: \nLoop invariant for the i-th iteration of the outer loop: `e_value = min(arr[:e])`\nLoop invariant for the j-th iteration of the inner loop: `z_value = min(arr[z:])`"}, {"role": "user", "content": "def selection_sort(arr):\n    e = 0\n    while e <= len(arr) - 1:\n        z = e + 1\n        while z <= len(arr) - 1:\n            if arr[z] < arr[e]:\n                temp = arr[e]\n                arr[e] = arr[z]\n                arr[z] = temp\n            z += 1\n        e += 1\n    return arr"}, {"role": "assistant", "content": "Problem 1:\nDescription: Suppose we have an array of integers, and we want to sort it using the selection sort algorithm. The implementation in the provided program contains an off-by-one error in the loop condition. It checks `e <= len(arr) - 1` instead of `e < len(arr)`. This may cause an `IndexError` when trying to access `arr[e]` in the last iteration.\nSolution: Modify the loop condition of the outer loop to `e < len(arr)` to prevent accessing `arr[e]` out of bounds.\n\nProblem 2:\nDescription: Suppose we have an array of strings, and we want to sort it using the selection sort algorithm. The implementation in the provided program contains a mistake in the loop condition. It compares the index `e` with `len(arr) - 1`, which may result in an off-by-one error causing incorrect comparisons.\nSolution: Correct the loop condition of the outer loop to `e < len(arr)` to ensure that all elements are considered for sorting.\n\nProblem 3:\nDescription: Suppose we have an array of floats, and we want to sort it using the selection sort algorithm. The given program has a bug that results in an incorrect comparison and swapping of elements. The issue lies in the loop condition of the inner loop. Currently, it compares `z` with `len(arr) - 1`, which may lead to an off-by-one error.\nSolution: Adjust the loop condition in the inner loop to `z < len(arr)` to ensure correct swapping and comparison of elements.\n\nTherefore, the final answer is: \nLoop invariant for the i-th iteration of the outer loop: `e_value = min(arr[:e])`\nLoop invariant for the j-th iteration of the inner loop: `z_value = min(arr[z:])`"}]