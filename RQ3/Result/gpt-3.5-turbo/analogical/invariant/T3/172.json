[{"role": "system", "content": "In the following questions, I will provide a target Python program code. The code is a program containing a loop, and the purpose of the code is indicated by its function name. Please provide a loop invariant for the i-th iteration of the loop to prove the partial correctness of the program. The loop invariant should be written in the form 'xxx_value = fun(arr[xxx]->arr[xxx])'. (Please note that your answer should only contain statements in the specified format.)(For each problem, you need to first present three related but not identical problems, along with a description of each problem and its solution. Finally, provide the answer to the original problem in the form of \"Therefore, the final answer is: \".)"}, {"role": "user", "content": "def insertion_sort(arr):\n    m = 0\n    while m < len(arr):\n        z = i\n        while z > 0 and arr[z - 1] > arr[z]:\n            temp = arr[z]\n            arr[z] = arr[z - 1]\n            arr[z - 1] = temp\n            z -= 1\n        m += 1\n    return arr"}, {"role": "assistant", "content": "Three related problems:\n\n1. **Problem:** Prove the correctness of a selection sort algorithm.\n   - **Loop invariant:** 'j_value = arr[j] = min(arr[j:len(arr)])'\n   - **Description:** In each iteration of the outer loop, the inner loop selects the minimum element in the unsorted part of the array and swaps it with the element at the beginning of the unsorted part.\n   - **Solution:** After each iteration of the outer loop, the invariant 'j_value = arr[j] = min(arr[j:len(arr)])' holds true. At the end, the entire array is sorted.\n   \n2. **Problem:** Prove the correctness of a bubble sort algorithm.\n   - **Loop invariant:** 'k_value = arr[k] = max(arr[0:k+1])'\n   - **Description:** In each iteration of the loop, the algorithm moves the largest element to the end of the array by swapping adjacent elements.\n   - **Solution:** The loop invariant 'k_value = arr[k] = max(arr[0:k+1])' holds true after each iteration, ensuring that the subarray from index 0 to k contains the k+1 largest elements in sorted order.\n   \n3. **Problem:** Prove the correctness of a merge sort algorithm.\n   - **Loop invariant:** 'split_value = len(arr)//2 = len(subarray1) + len(subarray2)'\n   - **Description:** The merge sort algorithm recursively divides the array into halves until each subarray has only one element, and then merges them back in a sorted manner.\n   - **Solution:** Throughout the recursion and merging process, the loop invariant 'split_value = len(arr)//2 = len(subarray1) + len(subarray2)' is maintained, guaranteeing that the array is correctly split into two equal halves at each step.\n\nTherefore, the final answer is: 'z = index of the current element being checked in the inner loop'"}, {"role": "user", "content": "def insertion_sort(arr):\n    m = len(arr)\n    while m > 0:\n        z = i\n        while z < len(arr) and arr[z - 1] > arr[z]:\n            temp = arr[z]\n            arr[z] = arr[z - 1]\n            arr[z - 1] = temp\n            z += 1\n        m -= 1\n    return arr"}, {"role": "assistant", "content": "Three related problems:\n\n1. **Problem:** Prove the correctness of a selection sort algorithm.\n   - **Loop invariant:** 'j_value = arr[j] = min(arr[j:len(arr)])'\n   - **Description:** In each iteration of the outer loop, the inner loop selects the minimum element in the unsorted part of the array and swaps it with the element at the beginning of the unsorted part.\n   - **Solution:** After each iteration of the outer loop, the invariant 'j_value = arr[j] = min(arr[j:len(arr)])' holds true. At the end, the entire array is sorted.\n   \n2. **Problem:** Prove the correctness of a bubble sort algorithm.\n   - **Loop invariant:** 'k_value = arr[k] = max(arr[0:k+1])'\n   - **Description:** In each iteration of the loop, the algorithm moves the largest element to the end of the array by swapping adjacent elements.\n   - **Solution:** The loop invariant 'k_value = arr[k] = max(arr[0:k+1])' holds true after each iteration, ensuring that the subarray from index 0 to k contains the k+1 largest elements in sorted order.\n   \n3. **Problem:** Prove the correctness of a quicksort algorithm.\n   - **Loop invariant:** 'pivot_value = arr[pivot_index] = value used to partition the array'\n   - **Description:** Quicksort selects a pivot element, partitions the array around the pivot, and recursively sorts the subarrays.\n   - **Solution:** Throughout the partitioning process, the loop invariant 'pivot_value = arr[pivot_index] = value used to partition the array' is maintained, ensuring that elements less than the pivot are on the left and elements greater are on the right.\n\nTherefore, the final answer is: 'z = index of the current element being checked in the inner loop'"}]