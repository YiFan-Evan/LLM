[{"role": "user", "content": "In the following questions, I will provide a target Python program code. The code is a program containing a loop, and the purpose of the code is indicated by its function name. Please provide a loop invariant for the i-th iteration of the loop to prove the partial correctness of the program. The loop invariant should be written in the form 'xxx_value = fun(arr[xxx]->arr[xxx])'. (Please note that your answer should only contain statements in the specified format.)(For each problem, you need to first present three related but not identical problems, along with a description of each problem and its solution. Finally, provide the answer to the original problem in the form of \"Therefore, the final answer is: \".)"}, {"role": "assistant", "content": "OK."}, {"role": "user", "content": "def selection_sort(arr):\n    g = 0\n    while g < len(arr):\n        z = g + 1\n        while z < len(arr):\n            if arr[z] < arr[g]:\n                temp = arr[g]\n                arr[g] = arr[z]\n                arr[z] = temp\n            z += 1\n        g += 1\n    return arr"}, {"role": "assistant", "content": "\"Here are three related but not identical problems:\\n\\n1. **Bubble Sort Problem:**\\n   - **Description:** Implement a bubble sort algorithm to sort an array in ascending order.\\n   - **Solution:** The bubble sort algorithm repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which means the list is sorted.\\n   - **Loop Invariant:** `sorted_prefix_value = fun(arr[0]->arr[i-1])` at the end of each outer loop iteration, where `i` is the current iteration index of the outer loop.\\n\\n2. **Insertion Sort Problem:**\\n   - **Description:** Write a function to perform insertion sort on an array, ensuring the array is sorted in ascending order.\\n   - **Solution:** Insertion sort iterates through an input list, taking one element at a time and inserting it into the correct position within a sorted subsection of the list.\\n   - **Loop Invariant:** `sorted_prefix_value = fun(arr[0]->arr[i])` at the beginning of each iteration of the inner loop, where `i` is the current iteration index of the inner loop.\\n\\n3. **Merge Sort Problem:**\\n   - **Description:** Create a function that performs merge sort on an array to sort it in ascending order.\\n   - **Solution:** Merge sort is a divide and conquer algorithm that divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves.\\n   - **Loop Invariant:** This algorithm doesn't fit the specified format since it involves recursive calls rather than a loop. However, if we consider the merge step, a possible invariant could be: `merged_value = fun(left_half_sorted_value->right_half_sorted_value)` after each merge operation.\\n\\nNow, for the original problem, which is the selection sort algorithm:\\n\\n- **Loop Invariant:** `min_value_in_prefix = fun(arr[0]->arr[g-1])` at the end of each iteration of the outer loop, where `g` is the current iteration index of the outer loop. The loop invariant states that the minimum value in the prefix of the array from the start up to but not including the current index `g` is correctly placed in `arr[g-1]` after each iteration of the outer loop.\\n\\nTherefore, the final answer is:\\n`min_value_in_prefix = fun(arr[0]->arr[g-1])`\""}, {"role": "user", "content": "def selection_sort(arr):\n    g = 0\n    while g <= len(arr) - 1:\n        z = g + 1\n        while z <= len(arr) - 1:\n            if arr[z] < arr[g]:\n                temp = arr[g]\n                arr[g] = arr[z]\n                arr[z] = temp\n            z += 1\n        g += 1\n    return arr"}, {"role": "assistant", "content": "\"For the provided `selection_sort` function, the loop invariant for the i-th iteration of the outer loop (where `g` is the loop variable and represents the current iteration index) can be stated as follows:\\n\\n- **Loop Invariant:** `min_value_in_prefix_g = fun(arr[0]->arr[g-1])`\\n\\nThis invariant states that after `g` iterations of the outer loop, the subarray `arr[0...g-1]` contains the smallest `g` elements from the original array, and they are sorted in ascending order. The value `arr[g-1]` is the smallest value encountered in the first `g` elements.\\n\\nFor the inner loop, which involves the variable `z`, the loop invariant can be stated as follows:\\n\\n- **Loop Invariant:** `min_value_in_suffix_z = fun(arr[z]->arr[len(arr)-1])`\\n\\nThis invariant states that during the `z`-th iteration of the inner loop, the smallest value in the suffix `arr[z...len(arr)-1]` has been found and is currently located at `arr[z]`.\\n\\nHowever, since you have asked for the loop invariant in the specific format 'xxx_value = fun(arr[xxx]->arr[xxx])', and considering that the inner loop's invariant is dependent on the outer loop's progress, the most relevant invariant for the outer loop is:\\n\\nTherefore, the final answer is:\\n\\n`min_value_in_prefix_g = fun(arr[0]->arr[g-1])`\""}]