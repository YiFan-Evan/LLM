[{"role": "user", "content": "In the following questions, I will provide a target Python program code. The code is a program containing a loop, and the purpose of the code is indicated by its function name. Please provide a loop invariant for the i-th iteration of the loop to prove the partial correctness of the program. The loop invariant should be written in the form 'xxx_value = fun(arr[xxx]->arr[xxx])'. (Please note that your answer should only contain statements in the specified format.)(For each problem, you need to first present three related but not identical problems, along with a description of each problem and its solution. Finally, provide the answer to the original problem in the form of \"Therefore, the final answer is: \".)"}, {"role": "assistant", "content": "OK."}, {"role": "user", "content": "def selection_sort(arr):\n    n = 0\n    while n < len(arr):\n        z = n + 1\n        while z < len(arr):\n            if arr[z] < arr[n]:\n                temp = arr[n]\n                arr[n] = arr[z]\n                arr[z] = temp\n            z += 1\n        n += 1\n    return arr"}, {"role": "assistant", "content": "\"Here are three related problems with their descriptions and solutions:\\n\\n1. **Problem: Bubble Sort**\\n   - **Description:** Implement a bubble sort algorithm that sorts an array in ascending order by repeatedly swapping adjacent elements if they are in the wrong order.\\n   - **Solution Loop Invariant:** `arr[0->i] <= arr[i+1->j]` for `0 <= i < j <= k` during the k-th pass, where the k-th pass ensures that the largest `k` elements are in their correct position.\\n\\n2. **Problem: Insertion Sort**\\n   - **Description:** Write a function that performs insertion sort on an array, where each iteration of the loop inserts the next element into its correct position relative to the already sorted elements.\\n   - **Solution Loop Invariant:** `arr[0->i-1]` is sorted and contains the same elements as the original array for `0 <= i <= k`, after `k` iterations.\\n\\n3. **Problem: Merge Sort**\\n   - **Description:** Create a recursive merge sort function that divides the array into halves, sorts each half, and then merges the sorted halves back together.\\n   - **Solution Loop Invariant:** `left[0->i] <= right[0->j]` after the merge step, where `left` and `right` are the two halves being merged, and `i` and `j` are their respective indices.\\n\\nNow, for the original problem, which is the selection sort algorithm:\\n\\n- **Loop Invariant:** `arr[0->n-1]` is sorted and contains the smallest `n` elements in their correct positions from the original array for `0 <= n <= len(arr)`, after `n` iterations of the outer loop.\\n\\nTherefore, the final answer is:\\n`arr[0->n-1] is sorted and contains the smallest n elements in their correct positions from the original array`\""}, {"role": "user", "content": "def selection_sort(arr):\n    n = 0\n    while n <= len(arr) - 1:\n        z = n + 1\n        while z <= len(arr) - 1:\n            if arr[z] < arr[n]:\n                temp = arr[n]\n                arr[n] = arr[z]\n                arr[z] = temp\n            z += 1\n        n += 1\n    return arr"}, {"role": "assistant", "content": "\"For the provided selection sort algorithm, the loop invariant can be described as follows:\\n\\n- **Loop Invariant for the i-th iteration of the outer loop:**\\n  `arr[0->i-1] is sorted and contains the smallest i elements in their correct positions`\\n\\n- **Loop Invariant for the j-th iteration of the inner loop:**\\n  `arr[0->n-1] contains the same elements as the original array, and the smallest element among arr[n->j] has been moved to arr[n]`\\n\\nNow, let's provide three related problems, their descriptions, and the loop invariants for each:\\n\\n1. **Problem: Find Minimum in Subarray**\\n   - **Description:** Write a function to find the minimum element in a subarray of an array.\\n   - **Solution Loop Invariant:** `min_value = min(arr[0->i])` for each iteration `i` of the loop, where `min_value` holds the minimum value found in the subarray from index `0` to `i`.\\n\\n2. **Problem: Linear Search**\\n   - **Description:** Implement a linear search algorithm to find the index of a target value in an array.\\n   - **Solution Loop Invariant:** `target_not_found = not (arr[0->i] contains target)` for each iteration `i` of the loop, indicating that the target has not been found in the array up to index `i`.\\n\\n3. **Problem: Reverse Array**\\n   - **Description:** Write a program to reverse the elements of an array in place.\\n   - **Solution Loop Invariant:** `arr[0->i] and arr[n-i-1->n-1] are swapped` for each iteration `i` of the loop, where `n` is the length of the array, ensuring that elements are being swapped from the ends towards the center.\\n\\nFor the original selection sort problem, considering the loop invariants provided:\\n\\nTherefore, the final answer is: `arr[0->n-1] is sorted and contains the smallest n elements in their correct positions`, where `n` is the length of the array `arr`.\""}]