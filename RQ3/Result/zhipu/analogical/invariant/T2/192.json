[{"role": "user", "content": "In the following questions, I will provide a target Python program code. The code is a program containing a loop, and the purpose of the code is indicated by its function name. Please provide a loop invariant for the i-th iteration of the loop to prove the partial correctness of the program. The loop invariant should be written in the form 'xxx_value = fun(arr[xxx]->arr[xxx])'. (Please note that your answer should only contain statements in the specified format.)(For each problem, you need to first present three related but not identical problems, along with a description of each problem and its solution. Finally, provide the answer to the original problem in the form of \"Therefore, the final answer is: \".)"}, {"role": "assistant", "content": "OK."}, {"role": "user", "content": "def selection_sort(arr):\n    m = 0\n    while m < len(arr):\n        z = m + 1\n        while z < len(arr):\n            if arr[z] < arr[m]:\n                temp = arr[m]\n                arr[m] = arr[z]\n                arr[z] = temp\n            z += 1\n        m += 1\n    return arr"}, {"role": "assistant", "content": "\"Here are three related but not identical problems:\\n\\n1. **Problem 1: Bubble Sort**\\n   - **Description**: Implement a bubble sort algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.\\n   - **Solution**: The loop invariant for the i-th iteration of the bubble sort's inner loop could be: `arr[0...n-i-1]_value = fun(arr[0...n-i-1]->arr[0...n-i-1])`, indicating that after i iterations, the first i elements are in their correct position.\\n\\n2. **Problem 2: Insertion Sort**\\n   - **Description**: Sort an array using the insertion sort algorithm where elements are picked from the unsorted part and placed at the correct position in the sorted part.\\n   - **Solution**: The loop invariant for the i-th iteration of the insertion sort's inner loop might be: `arr[0...i]_value = fun(arr[0...i]->arr[0...i])`, stating that after i iterations, the subarray arr[0...i] contains the same elements as the original array but is sorted.\\n\\n3. **Problem 3: Merge Sort**\\n   - **Description**: Write a program to sort an array using the merge sort algorithm, which divides the array into halves, recursively sorts them, and then merges the sorted halves.\\n   - **Solution**: The loop invariant for the merge step might be: `left_half_value = fun(left_half->left_half) and right_half_value = fun(right_half->right_half)`, indicating that each half of the array is sorted before merging.\\n\\nNow, for the original problem of the selection sort algorithm:\\n\\nThe loop invariant for the selection sort provided would be:\\n\\n- Before the first iteration of the outer loop, `arr[0...n-1]_value = fun(arr[0...n-1]->arr[0...n-1])` (the array is in its original unordered state).\\n- At the i-th iteration of the outer loop, `arr[0...i-1]_value = fun(arr[0...i-1]->arr[0...i-1])`, which means that the subarray arr[0...i-1] is sorted and contains the smallest i elements in their correct positions.\\n- Therefore, the final answer is: `arr[0...m-1]_value = fun(arr[0...m-1]->arr[0...m-1])`\""}, {"role": "user", "content": "def selection_sort(arr):\n    m = -1\n    while m < len(arr) - 1:\n        m += 1\n        z = m + 1\n        while z < len(arr):\n            if arr[z] < arr[m]:\n                temp = arr[m]\n                arr[m] = arr[z]\n                arr[z] = temp\n            z += 1\n    return arr"}, {"role": "assistant", "content": "\"For the provided selection sort algorithm, the loop invariant for the i-th iteration of the outer loop can be described as follows:\\n\\n- At the start of each iteration of the outer loop (when `m` is about to be incremented), the subarray `arr[0...m]` contains the same elements as the original array, but the first `m+1` elements are the smallest `m+1` elements from the original array, and they are in their correct sorted positions.\\n\\nTherefore, the loop invariant for the i-th iteration of the outer loop (where `m` is the loop control variable and is currently at `i-1` after `i-1` iterations) would be:\\n\\n`arr[0...i]_value = fun(arr[0...i]->arr[0...i])`\\n\\nThis states that after `i` iterations, the subarray `arr[0...i]` is sorted and contains the smallest `i` elements in their correct positions.\\n\\nNow, for the three related problems:\\n\\n1. **Problem 1: Find Minimum in Subarray**\\n   - **Description**: Write a program that finds the minimum element in a subarray of the original array.\\n   - **Solution**: The loop invariant might be `min_value = fun(subarray[0...z]->subarray[0...z])`, stating that at any point during the loop, `min_value` holds the minimum value found in the subarray `subarray[0...z]`.\\n\\n2. **Problem 2: Swap Elements in Array**\\n   - **Description**: Write a program that swaps two specific elements in an array if a certain condition is met.\\n   - **Solution**: The loop invariant might be `swapped_elements_value = fun(array[elem1...elem2]->array[elem1...elem2])`, indicating that if the condition is met, the elements at indices `elem1` and `elem2` have been swapped.\\n\\n3. **Problem 3: Linear Search**\\n   - **Description**: Implement a linear search algorithm to find the index of the first occurrence of a given element in an array.\\n   - **Solution**: The loop invariant might be `found_index_value = fun(array[0...i]->array[0...i])`, which implies that `found_index_value` holds the index of the element if found within the first `i` elements of the array.\\n\\nFor the original problem, the final answer is:\\n\\n`Therefore, the final answer is: arr[0...m]_value = fun(arr[0...m]->arr[0...m])`\""}]