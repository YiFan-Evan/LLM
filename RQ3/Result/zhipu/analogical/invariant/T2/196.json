[{"role": "user", "content": "In the following questions, I will provide a target Python program code. The code is a program containing a loop, and the purpose of the code is indicated by its function name. Please provide a loop invariant for the i-th iteration of the loop to prove the partial correctness of the program. The loop invariant should be written in the form 'xxx_value = fun(arr[xxx]->arr[xxx])'. (Please note that your answer should only contain statements in the specified format.)(For each problem, you need to first present three related but not identical problems, along with a description of each problem and its solution. Finally, provide the answer to the original problem in the form of \"Therefore, the final answer is: \".)"}, {"role": "assistant", "content": "OK."}, {"role": "user", "content": "def selection_sort(arr):\n    q = 0\n    while q < len(arr):\n        z = q + 1\n        while z < len(arr):\n            if arr[z] < arr[q]:\n                temp = arr[q]\n                arr[q] = arr[z]\n                arr[z] = temp\n            z += 1\n        q += 1\n    return arr"}, {"role": "assistant", "content": "\"Here are three related problems, each with a description and its solution:\\n\\n1. **Problem: Bubble Sort**\\n   - **Description:** Implement the bubble sort algorithm which repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.\\n   - **Solution Loop Invariant:** `sorted_prefix_value = fun(arr[0]->arr[q-1])` where after the q-th iteration, the first q elements are sorted.\\n\\n2. **Problem: Insertion Sort**\\n   - **Description:** Implement the insertion sort algorithm that builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.\\n   - **Solution Loop Invariant:** `sorted_prefix_value = fun(arr[0]->arr[i])` after the i-th iteration, the subarray consisting of the first i+1 elements is sorted.\\n\\n3. **Problem: Counting Sort**\\n   - **Description:** Given an array of integers, sort the array using the counting sort algorithm, which operates by counting the number of objects that have distinct key values. It is a non-comparison-based sorting algorithm suitable for sorting data with a small range of key values.\\n   - **Solution Loop Invariant:** `counted_values = fun(arr[z]->arr[z])` after each iteration, the count of elements less than or equal to the current element is incremented.\\n\\nNow, for the original problem, which is the selection sort algorithm:\\n\\n- **Loop Invariant for Selection Sort:** `min_value_at_index_value = fun(arr[0]->arr[q-1]->arr[q])` after the q-th iteration, the smallest value from the unsorted part of the array has been moved to the beginning of the array, and the first q elements of the array are the smallest q elements seen so far, though not necessarily sorted among themselves.\\n\\nTherefore, the final answer is:\\n`min_value_at_index_value = fun(arr[0]->arr[q-1]->arr[q])`\""}, {"role": "user", "content": "def selection_sort(arr):\n    q = -1\n    while q < len(arr) - 1:\n        q += 1\n        z = q + 1\n        while z < len(arr):\n            if arr[z] < arr[q]:\n                temp = arr[q]\n                arr[q] = arr[z]\n                arr[z] = temp\n            z += 1\n    return arr"}, {"role": "assistant", "content": "\"For the modified selection sort algorithm provided, where the loop starts with `q = -1` and increments `q` before entering the inner loop, here are three related problems with their descriptions and solutions:\\n\\n1. **Problem: Reverse Selection Sort**\\n   - **Description:** Implement a variant of selection sort that sorts the array in descending order by selecting the largest element and placing it at the end of the array, repeatedly, until the entire array is sorted.\\n   - **Solution Loop Invariant:** `max_value_at_index_value = fun(arr[0]->arr[q-1]->arr[q])` After the q-th iteration, the largest value from the unsorted part of the array has been moved to the end of the array, ensuring that the last q+1 elements are the largest seen so far.\\n\\n2. **Problem: Selection Sort with Duplicates**\\n   - **Description:** Implement the selection sort algorithm that sorts an array with possible duplicate values in ascending order. The algorithm should still correctly place the smallest element from the unsorted portion at the beginning of the array.\\n   - **Solution Loop Invariant:** `min_value_at_index_value = fun(arr[0]->arr[q-1]->arr[q])` After the q-th iteration, the smallest value among the unsorted elements is placed at the beginning of the array, and the first q+1 elements contain the smallest q+1 values from the array.\\n\\n3. **Problem: Selection Sort with Custom Comparator**\\n   - **Description:** Extend the selection sort algorithm to use a custom comparator function instead of the default less-than comparison to sort the array according to a custom ordering.\\n   - **Solution Loop Invariant:** `custom_order_value = fun(arr[0]->arr[q-1]->arr[q])` Assuming the custom comparator ensures a specific order, after the q-th iteration, the elements are arranged according to the custom order up to the q-th element.\\n\\nFor the original problem, which is the modified selection sort algorithm, the loop invariant can be stated as follows:\\n\\n- **Loop Invariant for Modified Selection Sort:**\\n  `min_value_at_index_value = fun(arr[0]->arr[q]->arr[q+1])`\\n  This invariant states that after q iterations, the smallest value found from index `q` to the end of the array has been moved to index `q`. This is true even though the initial value of `q` is `-1`, as the first increment of `q` will set it to `0` before the inner loop begins.\\n\\nTherefore, the final answer is:\\n`min_value_at_index_value = fun(arr[0]->arr[q]->arr[q+1])`\""}]