[{"role": "user", "content": "In the following questions, I will provide a target Python program code. The code is a program containing a loop, and the purpose of the code is indicated by its function name. Please provide a loop invariant for the i-th iteration of the loop to prove the partial correctness of the program. The loop invariant should be written in the form 'xxx_value = fun(arr[xxx]->arr[xxx])'. (Please note that your answer should only contain statements in the specified format.)(For each problem, you need to first present three related but not identical problems, along with a description of each problem and its solution. Finally, provide the answer to the original problem in the form of \"Therefore, the final answer is: \".)"}, {"role": "assistant", "content": "OK."}, {"role": "user", "content": "def selection_sort(arr):\n    p = 0\n    while p < len(arr):\n        z = p + 1\n        while z < len(arr):\n            if arr[z] < arr[p]:\n                temp = arr[p]\n                arr[p] = arr[z]\n                arr[z] = temp\n            z += 1\n        p += 1\n    return arr"}, {"role": "assistant", "content": "\"Here are three related but not identical problems:\\n\\n1. **Problem: Bubble Sort**\\n   - Description: Implement a bubble sort algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.\\n   - Solution: The loop invariant for the i-th iteration in a bubble sort could be: `arr[0...n-i]_value = fun(arr[0...n-i]->arr[0...n-i])`, which indicates that after i iterations, the first i elements are sorted.\\n\\n2. **Problem: Insertion Sort**\\n   - Description: Write a function that performs insertion sort on an array by building a sorted list one element at a time, taking elements from the unsorted part and inserting them into the correct position in the sorted part.\\n   - Solution: The loop invariant for the i-th iteration in insertion sort could be: `arr[0...i]_value = fun(arr[0...i]->arr[0...i])`, which indicates that the subarray arr[0...i] is sorted after i iterations.\\n\\n3. **Problem: Merge Sort**\\n   - Description: Create a function that uses merge sort to sort an array by dividing it into halves, sorting the halves, and then merging the sorted halves.\\n   - Solution: The loop invariant for the merge step (not a single loop but multiple recursive calls) could be: `arr[l...r]_value = fun(arr[l...m]->arr[m+1...r]->arr[l...r])`, indicating that after the merge step, the subarray arr[l...r] is sorted.\\n\\nNow, for the original problem with the selection sort algorithm provided:\\n\\nThe loop invariant for the selection sort algorithm should express that after p iterations, the first p elements are sorted and are the smallest elements found so far in the array. The loop invariant for the i-th iteration (where i corresponds to p in the provided code) is:\\n\\n`arr[0...p]_value = fun(arr[0...p]->arr[0...p])`\\n\\nTherefore, the final answer is:\\n`arr[0...p]_value = fun(arr[0...p]->arr[0...p])`\""}, {"role": "user", "content": "def selection_sort(arr):\n    p = len(arr)\n    while p > 0:\n        p -= 1\n        z = i\n        while z > 0:\n            z -= 1\n            if arr[z] < arr[p]:\n                temp = arr[p]\n                arr[p] = arr[z]\n                arr[z] = temp\n    return arr"}, {"role": "assistant", "content": "\"It seems there is a mistake in the code snippet you've provided. The variable `i` is not defined within the context of the code, and the loop logic appears to be incorrect for the selection sort algorithm. Selection sort typically involves finding the minimum element from the unsorted part of the array and moving it to the beginning of the array.\\n\\nLet's correct the code and then provide the related problems and the loop invariant for the corrected selection sort algorithm:\\n\\n```python\\ndef selection_sort(arr):\\n    p = len(arr) - 1\\n    while p > 0:\\n        min_index = p\\n        for z in range(p):\\n            if arr[z] < arr[min_index]:\\n                min_index = z\\n        temp = arr[p]\\n        arr[p] = arr[min_index]\\n        arr[min_index] = temp\\n        p -= 1\\n    return arr\\n```\\n\\nHere are three related but not identical problems:\\n\\n1. **Problem: Reverse Selection Sort**\\n   - Description: Modify the selection sort algorithm to sort the array in descending order instead of ascending order.\\n   - Solution: The loop invariant would be similar to the standard selection sort but would indicate that the largest elements are being moved to the end of the array instead.\\n\\n2. **Problem: Selection Sort with Duplicates**\\n   - Description: Adapt the selection sort algorithm to handle an array that contains duplicate elements and ensure that the sort is stable (i.e., the relative order of equal elements is preserved).\\n   - Solution: The loop invariant would reflect that after each iteration, the minimum element found so far is correctly placed in its position, and duplicates are handled according to the stability requirement.\\n\\n3. **Problem: Selection Sort with Custom Comparator**\\n   - Description: Generalize the selection sort algorithm to accept a custom comparator function that defines the order of elements.\\n   - Solution: The loop invariant would reflect that the array is being sorted according to the custom comparator function provided.\\n\\nNow, for the loop invariant of the corrected selection sort algorithm:\\n\\nThe loop invariant for the i-th iteration should state that after i iterations through the outer loop, the last i elements of the array are sorted in ascending order, and the minimum element found in the unsorted portion has been placed in its correct position.\\n\\nTherefore, the loop invariant is:\\n\\n`arr[n-i...n]_value = fun(arr[n-i...n]->arr[n-i...n])`\\n\\nWhere `n` is the length of the array and `i` is the current iteration of the outer loop.\\n\\nTherefore, the final answer is:\\n\\n`arr[n-i...n]_value = fun(arr[n-i...n]->arr[n-i...n])`\""}]