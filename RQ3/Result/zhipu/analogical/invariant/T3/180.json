[{"role": "user", "content": "In the following questions, I will provide a target Python program code. The code is a program containing a loop, and the purpose of the code is indicated by its function name. Please provide a loop invariant for the i-th iteration of the loop to prove the partial correctness of the program. The loop invariant should be written in the form 'xxx_value = fun(arr[xxx]->arr[xxx])'. (Please note that your answer should only contain statements in the specified format.)(For each problem, you need to first present three related but not identical problems, along with a description of each problem and its solution. Finally, provide the answer to the original problem in the form of \"Therefore, the final answer is: \".)"}, {"role": "assistant", "content": "OK."}, {"role": "user", "content": "def selection_sort(arr):\n    a = 0\n    while a < len(arr):\n        z = a + 1\n        while z < len(arr):\n            if arr[z] < arr[a]:\n                temp = arr[a]\n                arr[a] = arr[z]\n                arr[z] = temp\n            z += 1\n        a += 1\n    return arr"}, {"role": "assistant", "content": "\"Here are three related but not identical problems, each with a description and its solution:\\n\\n1. **Problem: Bubble Sort**\\n   - **Description:** Implement a bubble sort algorithm that sorts an array in ascending order by repeatedly swapping adjacent elements if they are in the wrong order.\\n   - **Solution Loop Invariant:** `arr[0->i-1] = fun(arr[0->i-1])` for the i-th iteration of the outer loop, which indicates that the first i elements are sorted.\\n\\n2. **Problem: Insertion Sort**\\n   - **Description:** Write a function that performs insertion sort on an array. This sorting algorithm builds the final sorted array one item at a time, picking elements from the unsorted part and placing them at the correct position in the sorted part.\\n   - **Solution Loop Invariant:** `arr[0->j] = fun(arr[0->j])` for the j-th iteration of the loop, meaning that the subarray consisting of the first j+1 elements is sorted.\\n\\n3. **Problem: Merge Sort**\\n   - **Description:** Create a merge sort function that divides the array into halves, recursively sorts each half, and then merges the sorted halves back together.\\n   - **Solution Loop Invariant:** Not as straightforward as the previous two since merge sort uses recursion and not a simple loop. However, a loop invariant for the merge step could be `left[i->j] + right[k->l] = fun(left[i->j], right[k->l])`, indicating that the subarrays left[i...j] and right[k...l] have been merged into the correct order.\\n\\nNow, for the original problem with the selection sort algorithm, the loop invariant can be stated as:\\n\\n`arr[0->a-1] = fun(arr[0->a-1]->arr[a->len(arr)-1])`\\n\\nThis invariant asserts that for the i-th iteration of the outer loop (where i = a), the subarray from the start to the element before `a` is sorted, and it holds true until `a` reaches the length of the array.\\n\\nTherefore, the final answer is: `arr[0->a-1] = fun(arr[0->a-1]->arr[a->len(arr)-1])`\""}, {"role": "user", "content": "def selection_sort(arr):\n    a = len(arr)\n    while a > 0:\n        a -= 1\n        z = i\n        while z > 0:\n            z -= 1\n            if arr[z] < arr[a]:\n                temp = arr[a]\n                arr[a] = arr[z]\n                arr[z] = temp\n    return arr"}, {"role": "assistant", "content": "\"It seems there's a small error in the provided code snippet. The variable `i` is used but not defined within the function. Assuming that `i` is meant to be the index `a` from the outer loop, let's correct the code snippet and then provide the related problems and the loop invariant for the original problem.\\n\\nHere's the corrected code snippet:\\n\\n```python\\ndef selection_sort(arr):\\n    a = len(arr)\\n    while a > 0:\\n        max_index = 0\\n        for z in range(1, a):\\n            if arr[z] > arr[max_index]:\\n                max_index = z\\n        temp = arr[a-1]\\n        arr[a-1] = arr[max_index]\\n        arr[max_index] = temp\\n        a -= 1\\n    return arr\\n```\\n\\nNow, let's provide three related problems:\\n\\n1. **Problem: Reverse Selection Sort**\\n   - **Description:** Modify the selection sort algorithm to sort an array in descending order.\\n   - **Solution Loop Invariant:** `arr[0->a-1] = fun(arr[a->len(arr)-1]->arr[0->a-2])` for the i-th iteration of the outer loop, indicating that the largest elements are bubbled to the beginning of the array.\\n\\n2. **Problem: Stability Check for Selection Sort**\\n   - **Description:** Adapt the selection sort algorithm to ensure that it is stable (i.e., the relative order of equal elements is preserved).\\n   - **Solution Loop Invariant:** This is more complex for stability, but a possible invariant could be `arr[0->a-1] = fun(arr[0->a-1]->arr[a->len(arr)-1])` with additional conditions to ensure stability.\\n\\n3. **Problem: Selection Sort with Custom Comparator**\\n   - **Description:** Extend the selection sort algorithm to accept a custom comparator function to define the sorting order.\\n   - **Solution Loop Invariant:** `arr[0->a-1] = fun(arr[a->len(arr)-1], comp)` for the i-th iteration of the outer loop, where `comp` is the custom comparator function.\\n\\nNow, for the loop invariant of the original problem, we can state the following:\\n\\n`arr[0->len(arr)-a] = fun(arr[0->len(arr)-a]->arr[len(arr)-a->len(arr)-1])`\\n\\nThis invariant asserts that after `a` iterations of the outer loop, the last `a` elements of the array are the largest `a` elements of the original array, and they are placed in the correct position at the end of the array.\\n\\nTherefore, the final answer is: `arr[0->len(arr)-a] = fun(arr[0->len(arr)-a]->arr[len(arr)-a->len(arr)-1])`\""}]