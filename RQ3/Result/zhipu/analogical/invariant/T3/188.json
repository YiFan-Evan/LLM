[{"role": "user", "content": "In the following questions, I will provide a target Python program code. The code is a program containing a loop, and the purpose of the code is indicated by its function name. Please provide a loop invariant for the i-th iteration of the loop to prove the partial correctness of the program. The loop invariant should be written in the form 'xxx_value = fun(arr[xxx]->arr[xxx])'. (Please note that your answer should only contain statements in the specified format.)(For each problem, you need to first present three related but not identical problems, along with a description of each problem and its solution. Finally, provide the answer to the original problem in the form of \"Therefore, the final answer is: \".)"}, {"role": "assistant", "content": "OK."}, {"role": "user", "content": "def selection_sort(arr):\n    i = 0\n    while i < len(arr):\n        z = i + 1\n        while z < len(arr):\n            if arr[z] < arr[i]:\n                temp = arr[i]\n                arr[i] = arr[z]\n                arr[z] = temp\n            z += 1\n        i += 1\n    return arr"}, {"role": "assistant", "content": "\"Here are three related problems with their descriptions and solutions:\\n\\n1. **Problem: Bubble Sort**\\n   - **Description:** Implement a bubble sort algorithm that sorts an array in ascending order. The algorithm repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.\\n   - **Solution Loop Invariant:** `arr[0->i-1] <= arr[i]` for each iteration of the outer loop, where `i` is the current index of the outer loop.\\n\\n2. **Problem: Insertion Sort**\\n   - **Description:** Write a function for insertion sort that takes an array and sorts it in ascending order. The algorithm builds the final sorted array one item at a time, picking the next element and inserting it into its correct position within the sorted part of the array.\\n   - **Solution Loop Invariant:** `arr[0->i]` is sorted for each iteration of the loop after the inner loop finishes, where `i` is the index of the current element being inserted.\\n\\n3. **Problem: Merge Sort**\\n   - **Description:** Create a merge sort function that divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves.\\n   - **Solution Loop Invariant:** After each merge operation, `arr[l->r]` contains the same elements as `arr[original_l->original_r]`, but in sorted order, where `l` and `r` are the current indices of the sub-array being merged, and `original_l` and `original_r` are the original indices before the split.\\n\\nNow, for the original problem of the selection sort algorithm, the loop invariant can be stated as follows:\\n\\n- **Selection Sort Loop Invariant:** `arr[0->i-1]` is sorted and contains the smallest `i` elements of the array in their correct positions for each iteration of the outer loop, where `i` is the current index of the outer loop.\\n\\nTherefore, the final answer is: `arr[0->i-1]_value = min(arr[0->i-1]->arr[0->i-1])`.\""}, {"role": "user", "content": "def selection_sort(arr):\n    i = len(arr)\n    while i > 0:\n        i -= 1\n        z = i\n        while z > 0:\n            z -= 1\n            if arr[z] < arr[i]:\n                temp = arr[i]\n                arr[i] = arr[z]\n                arr[z] = temp\n    return arr"}, {"role": "assistant", "content": "\"For the given selection sort algorithm, which is slightly modified to iterate in reverse order, here are three related problems with their descriptions and solutions:\\n\\n1. **Problem: Reverse Bubble Sort**\\n   - **Description:** Implement a bubble sort algorithm that sorts an array in descending order by repeatedly stepping through the list, comparing adjacent elements, and swapping them if they are in the wrong order.\\n   - **Solution Loop Invariant:** `arr[i+1->len(arr)-1] >= arr[i]` for each iteration of the outer loop, where `i` starts from `0` and decreases with each iteration.\\n\\n2. **Problem: Reverse Insertion Sort**\\n   - **Description:** Write a function for insertion sort that sorts an array in descending order. The algorithm builds the final sorted array one item at a time, picking the next element and inserting it into its correct position within the sorted part of the array.\\n   - **Solution Loop Invariant:** `arr[i]` is the largest among `arr[0->i]` and is placed in its correct position for each iteration of the loop after the inner loop finishes, where `i` starts from `len(arr)-1` and decreases.\\n\\n3. **Problem: Reverse Merge Sort**\\n   - **Description:** Create a merge sort function that sorts an array in descending order by dividing the input array into two halves, calling itself for the two halves, and then merging the two sorted halves in reverse order.\\n   - **Solution Loop Invariant:** After each merge operation, `arr[l->r]` contains the same elements as `arr[original_l->original_r]`, but in descending order, where `l` and `r` are the current indices of the sub-array being merged, and `original_l` and `original_r` are the original indices before the split.\\n\\nNow, for the modified selection sort algorithm provided, the loop invariant can be stated as follows:\\n\\n- **Modified Selection Sort Loop Invariant:** `arr[i+1->len(arr)-1]_value = max(arr[i+1->len(arr)-1]->arr[i+1->len(arr)-1])` for each iteration of the outer loop, where `i` starts from `len(arr)-1` and decreases with each iteration. This invariant states that the part of the array from `i+1` to the end is the largest elements found so far, sorted in descending order.\\n\\nTherefore, the final answer is: `arr[i+1->len(arr)-1]_value = max(arr[i+1->len(arr)-1]->arr[i+1->len(arr)-1])`.\""}]