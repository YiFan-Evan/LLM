[{"role": "user", "content": "In the following questions, I will provide a target Python program code. The code is a program containing a loop, and the purpose of the code is indicated by its function name. Please provide a loop invariant for the i-th iteration of the loop to prove the partial correctness of the program. The loop invariant should be written in the form 'xxx_value = fun(arr[xxx]->arr[xxx])'. (Please note that your answer should only contain statements in the specified format.)(For each problem, you need to first present three related but not identical problems, along with a description of each problem and its solution. Finally, provide the answer to the original problem in the form of \"Therefore, the final answer is: \".)"}, {"role": "assistant", "content": "OK."}, {"role": "user", "content": "def selection_sort(arr):\n    c = 0\n    while c < len(arr):\n        z = c + 1\n        while z < len(arr):\n            if arr[z] < arr[c]:\n                temp = arr[c]\n                arr[c] = arr[z]\n                arr[z] = temp\n            z += 1\n        c += 1\n    return arr"}, {"role": "assistant", "content": "\"Here are three related problems, each with a brief description and their respective solutions:\\n\\n1. **Problem: Bubble Sort**\\n   - **Description:** Implement a bubble sort algorithm that sorts an array in ascending order. The algorithm repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.\\n   - **Solution Loop Invariant:** `sorted_prefix_value = fun(arr[0]->arr[i-1])` at the i-th iteration of the outer loop, where `i` is the current index and `sorted_prefix_value` represents the fact that the subarray from the start up to the element before `i` is sorted.\\n\\n2. **Problem: Insertion Sort**\\n   - **Description:** Write a function that performs insertion sort on an array. It builds the final sorted array one item at a time, by inserting the current element into its correct position in the already sorted subarray.\\n   - **Solution Loop Invariant:** `sorted_prefix_value = fun(arr[0]->arr[i])` at the i-th iteration of the loop, where `i` is the current index and `sorted_prefix_value` represents the sorted state of the subarray from the start to the element at index `i`.\\n\\n3. **Problem: Merge Sort**\\n   - **Description:** Create a function that uses the merge sort algorithm to sort an array. Merge sort is a divide and conquer algorithm that divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves.\\n   - **Solution Loop Invariant:** Since merge sort doesn't have a single loop but rather recursive calls, the invariant would apply to each recursive call. For a given recursive call, `sorted_prefix_value = fun(arr[0]->arr[mid])` and `sorted_suffix_value = fun(arr[mid+1]->arr[end])` where `mid` is the index that splits the array into two halves and `sorted_prefix_value` and `sorted_suffix_value` represent the sorted state of the two subarrays.\\n\\nNow, for the original problem with the selection sort algorithm, the loop invariant can be stated as follows:\\n\\n**Therefore, the final answer is:** `min_value = fun(arr[c+1]->arr[n-1])`, which holds true after each iteration of the inner while loop, where `min_value` indicates that the smallest value in the unsorted portion of the array has been found and is now at its correct position at the end of the current sorted prefix, and `n` is the length of the array `arr`.\""}, {"role": "user", "content": "def selection_sort(arr):\n    c = len(arr)\n    while c > 0:\n        c -= 1\n        z = i\n        while z > 0:\n            z -= 1\n            if arr[z] < arr[c]:\n                temp = arr[c]\n                arr[c] = arr[z]\n                arr[z] = temp\n    return arr"}, {"role": "assistant", "content": "\"It seems there is a small mistake in the provided code snippet. The variable `i` is not defined within the context of the code. Assuming that `i` was meant to be the index `c` from the outer loop, let's correct the code and then provide the related problems and the loop invariant for the corrected code.\\n\\nHere is the corrected version of the selection sort algorithm:\\n\\n```python\\ndef selection_sort(arr):\\n    c = len(arr) - 1  # Start from the end of the array\\n    while c > 0:  # While there are elements to sort\\n        max_index = c\\n        for z in range(c):  # Find the index of the maximum element in the unsorted part\\n            if arr[z] > arr[max_index]:\\n                max_index = z\\n        # Swap the found maximum element with the last element in the unsorted part\\n        temp = arr[c]\\n        arr[c] = arr[max_index]\\n        arr[max_index] = temp\\n        c -= 1  # Move the boundary of the sorted and unsorted parts\\n    return arr\\n```\\n\\nNow, here are three related problems, their descriptions, and their solution loop invariants:\\n\\n1. **Problem: Reverse Selection Sort**\\n   - **Description:** Modify the selection sort algorithm to sort the array in descending order.\\n   - **Solution Loop Invariant:** `max_value = fun(arr[0]->arr[c])` after each iteration of the outer loop, where `max_value` indicates that the largest value in the unsorted portion of the array has been found and is now at its correct position at the start of the current sorted suffix.\\n\\n2. **Problem: Stability in Sorting**\\n   - **Description:** Adapt the selection sort algorithm to ensure it is stable, meaning that the relative order of equal elements is preserved.\\n   - **Solution Loop Invariant:** `stable_sorted_prefix_value = fun(arr[0]->arr[c])` after each iteration of the outer loop, where `stable_sorted_prefix_value` indicates that the subarray is sorted and stable up to index `c`.\\n\\n3. **Problem: Sort with Constraints**\\n   - **Description:** Implement the selection sort algorithm with an additional constraint that the elements must be sorted in a specific order, such as sorting by the second value in a pair of elements.\\n   - **Solution Loop Invariant:** `custom_order_value = fun(arr[0]->arr[c], secondary criteria)` after each iteration of the outer loop, where `custom_order_value` reflects the sorting based on the specified criteria up to index `c`.\\n\\nFor the original problem with the corrected selection sort algorithm, the loop invariant can be stated as follows:\\n\\n**Therefore, the final answer is:** `sorted_prefix_value = fun(arr[0]->arr[c-1])`, which holds true after each iteration of the outer loop, where `sorted_prefix_value` indicates that the subarray from the start to the element before `c` is sorted in ascending order.\""}]