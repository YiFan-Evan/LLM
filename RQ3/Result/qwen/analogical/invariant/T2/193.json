[{"role": "system", "content": "In the following questions, I will provide a target Python program code. The code is a program containing a loop, and the purpose of the code is indicated by its function name. Please provide a loop invariant for the i-th iteration of the loop to prove the partial correctness of the program. The loop invariant should be written in the form 'xxx_value = fun(arr[xxx]->arr[xxx])'. (Please note that your answer should only contain statements in the specified format.)(For each problem, you need to first present three related but not identical problems, along with a description of each problem and its solution. Finally, provide the answer to the original problem in the form of \"Therefore, the final answer is: \".)"}, {"role": "user", "content": "def selection_sort(arr):\n    n = 0\n    while n < len(arr):\n        z = n + 1\n        while z < len(arr):\n            if arr[z] < arr[n]:\n                temp = arr[n]\n                arr[n] = arr[z]\n                arr[z] = temp\n            z += 1\n        n += 1\n    return arr"}, {"role": "assistant", "content": "To solve this problem, let's first consider three related but not identical problems and their solutions.\n\n### Problem 1: Selection Sort with Array Length Check\n**Description**: Given an array `arr`, sort the array using the selection sort algorithm. Before starting the sorting process, check if the array length is greater than zero.\n- **Solution**: Add a condition at the beginning of the function to check if the array length is greater than zero. If it is not, return the array as is. This ensures that the sorting process does not start on an empty array.\n\n### Problem 2: Selection Sort with Duplicate Elements\n**Description**: Given an array `arr` with possible duplicate elements, sort the array using the selection sort algorithm.\n- **Solution**: The provided selection sort algorithm already handles duplicate elements correctly. It swaps elements based on their value comparison, so duplicate elements remain in their relative order.\n\n### Problem 3: Selection Sort with Array Length Greater Than One\n**Description**: Given an array `arr` with a length greater than one, sort the array using the selection sort algorithm.\n- **Solution**: Modify the initial condition of the outer loop to ensure that the loop only runs if the array length is greater than one. This can be done by adding a condition like `if len(arr) > 1:` before the outer loop starts.\n\nNow, we need to determine the loop invariant for the original problem, which is the selection sort algorithm provided.\n\n### Loop Invariant for Selection Sort\nThe loop invariant for the selection sort algorithm can be described as follows:\n\n- After the i-th iteration of the outer loop, the first i elements of the array are sorted in non-decreasing order.\n\nFormally, the loop invariant can be stated as:\n- `sorted_value = fun(arr[0:i+1])`\n\nSince the selection sort algorithm places the smallest element in the correct position during each pass of the inner loop, we can say that after the i-th iteration of the outer loop, the first i elements are sorted.\n\nTherefore, the final answer is:\n- `sorted_value = fun(arr[0:n+1])`"}, {"role": "user", "content": "def selection_sort(arr):\n    n = -1\n    while n < len(arr) - 1:\n        n += 1\n        z = n + 1\n        while z < len(arr):\n            if arr[z] < arr[n]:\n                temp = arr[n]\n                arr[n] = arr[z]\n                arr[z] = temp\n            z += 1\n    return arr"}, {"role": "assistant", "content": "Let's consider three related but not identical problems and their solutions to better understand the loop invariant for the given selection sort algorithm.\n\n### Problem 1: Selection Sort with Initial Index Adjustment\n**Description**: Given an array `arr`, sort the array using the selection sort algorithm. Start the outer loop index `n` from -1 instead of 0.\n- **Solution**: The provided code initializes `n` to -1 and increments it by 1 at the start of each iteration of the outer loop. This effectively makes the loop start from index 0, just like a standard selection sort algorithm.\n\n### Problem 2: Selection Sort with Different Loop Conditions\n**Description**: Given an array `arr`, sort the array using the selection sort algorithm. Change the loop conditions to ensure the loop runs correctly.\n- **Solution**: The current loop conditions are correct. The outer loop runs until `n < len(arr) - 1`, ensuring that the last element is considered by the inner loop. The inner loop runs until `z < len(arr)`, ensuring all elements after `n` are checked.\n\n### Problem 3: Selection Sort with Incrementing Inner Loop Index\n**Description**: Given an array `arr`, sort the array using the selection sort algorithm. Ensure the inner loop index `z` is incremented correctly within the loop.\n- **Solution**: The inner loop correctly increments `z` by 1 in each iteration, ensuring that all elements after `n` are compared.\n\nNow, we need to determine the loop invariant for the given selection sort algorithm.\n\n### Loop Invariant for Selection Sort\nThe loop invariant for the selection sort algorithm can be described as follows:\n\n- After the i-th iteration of the outer loop, the first i elements of the array are sorted in non-decreasing order.\n\nFormally, the loop invariant can be stated as:\n- `sorted_value = fun(arr[0:n+1])`\n\nThis means that after the i-th iteration of the outer loop, the first `n+1` elements of the array are sorted.\n\nTherefore, the final answer is:\n- `sorted_value = fun(arr[0:n+1])`"}]