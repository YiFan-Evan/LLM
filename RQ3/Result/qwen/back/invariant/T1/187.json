[{"role": "system", "content": "In the following questions, I will provide a target Python program code. The code is a program containing a loop, and the purpose of the code is indicated by its function name. Please provide a loop invariant for the i-th iteration of the loop to prove the partial correctness of the program. The loop invariant should be written in the form 'xxx_value = fun(arr[xxx]->arr[xxx])'. (Please note that your answer should only contain statements in the specified format.)(For each problem, you need to first explain the fundamental principles involved in solving it, and then provide the answer to the problem in the form of \"Therefore, the final answer is: \".)"}, {"role": "user", "content": "def selection_sort(arr):\n    h = 0\n    while h < len(arr):\n        z = h + 1\n        while z < len(arr):\n            if arr[z] < arr[h]:\n                temp = arr[h]\n                arr[h] = arr[z]\n                arr[z] = temp\n            z += 1\n        h += 1\n    return arr"}, {"role": "assistant", "content": "### Explanation of the Problem\n\nThe given Python program implements the Selection Sort algorithm, which sorts an array in ascending order. The fundamental principle of Selection Sort is to divide the input array into two parts: the subarray of items already sorted, which is built up from left to right at the front (left) of the array, and the subarray of items remaining to be sorted that occupy the rest of the array. Initially, the sorted subarray is empty and the unsorted subarray is the entire input array. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted subarray, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order), and moving the subarray boundaries one element to the right.\n\n### Loop Invariant\n\nTo prove the partial correctness of the Selection Sort algorithm, we need to identify a loop invariant for each iteration of the outer loop (which is controlled by the variable `h`). The loop invariant should describe the state of the array after each iteration of the outer loop.\n\n#### Outer Loop Invariant\n- **Invariant**: After the i-th iteration of the outer loop (i.e., when `h` equals `i`), the first `h` elements of the array are in sorted order and are the smallest `h` elements in the array.\n\nFormally, this can be stated as:\n- **Invariant**: The value of `arr[0:h]` is sorted and contains the smallest `h` elements of the original array.\n\nHowever, since we need to express the invariant in the specific format requested:\n\n- **Invariant**: `sorted_value = fun(arr[0:h] -> arr[0:h])`\n\nGiven that the sorted part of the array contains the smallest `h` elements in sorted order, we can write this as:\n\n- **Invariant**: `sorted_value = min(arr[0:h+1])`\n\nBut since the question asks for a more generic format, we can say:\n\n- **Invariant**: `sorted_value = fun(arr[0:h] -> arr[0:h])`\n\nWhere `fun` represents the fact that the first `h` elements are sorted and contain the smallest `h` elements.\n\n### Final Answer\nTherefore, the final answer is: \n- **Invariant**: `sorted_value = fun(arr[0:h] -> arr[0:h])`"}, {"role": "user", "content": "def selection_sort(arr):\n    h = 0\n    while h <= len(arr) - 1:\n        z = h + 1\n        while z <= len(arr) - 1:\n            if arr[z] < arr[h]:\n                temp = arr[h]\n                arr[h] = arr[z]\n                arr[z] = temp\n            z += 1\n        h += 1\n    return arr"}, {"role": "assistant", "content": "### Explanation of the Problem\n\nThe provided Python program is implementing the Selection Sort algorithm. The core idea behind Selection Sort is to sort the array by repeatedly finding the minimum element from the unsorted part of the array and putting it at the beginning. The algorithm maintains two subarrays in a given array:\n\n1. The subarray which is already sorted.\n2. The remaining subarray which is unsorted.\n\nIn every iteration of the outer loop (controlled by `h`), the algorithm finds the smallest element in the unsorted part of the array and swaps it with the element at the current position `h`. This way, the sorted part of the array grows one element at a time.\n\n### Loop Invariant\n\nTo prove the partial correctness of the Selection Sort algorithm, we need to identify a loop invariant for the outer loop (controlled by `h`).\n\n#### Outer Loop Invariant\n- **Invariant**: After the i-th iteration of the outer loop (i.e., when `h` equals `i`), the first `h` elements of the array are in sorted order and contain the smallest `h` elements of the array.\n\nFormally, this can be stated as:\n- **Invariant**: `sorted_value = fun(arr[0:h] -> arr[0:h])`\n\nHere, `fun` represents the fact that the first `h` elements are sorted and contain the smallest `h` elements.\n\n### Final Answer\nTherefore, the final answer is:\n- **Invariant**: `sorted_value = fun(arr[0:h] -> arr[0:h])`"}]