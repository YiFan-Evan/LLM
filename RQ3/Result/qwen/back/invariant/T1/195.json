[{"role": "system", "content": "In the following questions, I will provide a target Python program code. The code is a program containing a loop, and the purpose of the code is indicated by its function name. Please provide a loop invariant for the i-th iteration of the loop to prove the partial correctness of the program. The loop invariant should be written in the form 'xxx_value = fun(arr[xxx]->arr[xxx])'. (Please note that your answer should only contain statements in the specified format.)(For each problem, you need to first explain the fundamental principles involved in solving it, and then provide the answer to the problem in the form of \"Therefore, the final answer is: \".)"}, {"role": "user", "content": "def selection_sort(arr):\n    p = 0\n    while p < len(arr):\n        z = p + 1\n        while z < len(arr):\n            if arr[z] < arr[p]:\n                temp = arr[p]\n                arr[p] = arr[z]\n                arr[z] = temp\n            z += 1\n        p += 1\n    return arr"}, {"role": "assistant", "content": "### Fundamental Principles\n\nThe given Python function `selection_sort` implements the Selection Sort algorithm. This algorithm works by repeatedly finding the minimum element from the unsorted part of the array and putting it at the beginning. \n\n- In the outer loop (`while p < len(arr)`), the variable `p` represents the position up to which the array has been sorted.\n- In the inner loop (`while z < len(arr)`), the variable `z` scans through the unsorted portion of the array to find the smallest element.\n- If an element smaller than the current element at position `p` is found, these two elements are swapped.\n\nTo prove the partial correctness of this algorithm using loop invariants, we need to ensure that:\n1. At the start of each iteration of the outer loop, the subarray `arr[0:p]` is sorted.\n2. At the start of each iteration of the inner loop, the element at position `p` is the smallest in the subarray `arr[p:len(arr)]`.\n\n### Loop Invariant\n\nFor the outer loop:\n\n- **Invariant**: `sorted_value = fun(arr[0:p]->arr[0:p])`\n- **Explanation**: This means that the subarray `arr[0:p]` is sorted at the beginning of each iteration of the outer loop. Since Selection Sort is a comparison-based sorting algorithm, the elements in `arr[0:p]` are in non-decreasing order.\n\nFor the inner loop:\n\n- **Invariant**: `min_value = min(arr[p:z])`\n- **Explanation**: This means that at the start of each iteration of the inner loop, the value at index `p` is the smallest element in the subarray `arr[p:z]`. The inner loop finds the minimum element in the unsorted part of the array starting from index `p` and ending at `z-1`.\n\n### Final Answer\n\nTherefore, the final answer is:\n\n- Outer Loop Invariant: `sorted_value = fun(arr[0:p]->arr[0:p])`\n- Inner Loop Invariant: `min_value = min(arr[p:z])`"}, {"role": "user", "content": "def selection_sort(arr):\n    p = 0\n    while p <= len(arr) - 1:\n        z = p + 1\n        while z <= len(arr) - 1:\n            if arr[z] < arr[p]:\n                temp = arr[p]\n                arr[p] = arr[z]\n                arr[z] = temp\n            z += 1\n        p += 1\n    return arr"}, {"role": "assistant", "content": "### Fundamental Principles\n\nThe provided `selection_sort` function sorts an array by repeatedly finding the minimum element from the unsorted part and putting it at the beginning. The key steps include:\n\n- The outer loop runs from `p = 0` to `len(arr) - 1`, where `p` marks the boundary between the sorted and unsorted parts of the array.\n- The inner loop runs from `z = p + 1` to `len(arr) - 1`, searching for the smallest element in the unsorted part of the array.\n\nTo prove the partial correctness of the algorithm, we need to establish loop invariants for both the outer and inner loops.\n\n### Loop Invariants\n\n#### Outer Loop Invariant\n\n- **Invariant**: `sorted_value = fun(arr[0:p]->arr[0:p])`\n- **Explanation**: At the start of each iteration of the outer loop, the subarray `arr[0:p]` is sorted. This means that the elements in `arr[0:p]` are in non-decreasing order.\n\n#### Inner Loop Invariant\n\n- **Invariant**: `min_value = min(arr[p:z])`\n- **Explanation**: At the start of each iteration of the inner loop, the element at index `p` is the smallest in the subarray `arr[p:z]`. This means that the inner loop is scanning the unsorted part of the array to find the smallest element.\n\n### Final Answer\n\nTherefore, the final answer is:\n\n- Outer Loop Invariant: `sorted_value = fun(arr[0:p]->arr[0:p])`\n- Inner Loop Invariant: `min_value = min(arr[p:z])`"}]