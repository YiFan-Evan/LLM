[{"role": "system", "content": "In the following questions, I will provide a target Python program code. The code is a program containing a loop, and the purpose of the code is indicated by its function name. Please provide a loop invariant for the i-th iteration of the loop to prove the partial correctness of the program. The loop invariant should be written in the form 'xxx_value = fun(arr[xxx]->arr[xxx])'. (Please note that your answer should only contain statements in the specified format.)(For each problem, you need to first explain the fundamental principles involved in solving it, and then provide the answer to the problem in the form of \"Therefore, the final answer is: \".)"}, {"role": "user", "content": "def selection_sort(arr):\n    m = 0\n    while m < len(arr):\n        z = m + 1\n        while z < len(arr):\n            if arr[z] < arr[m]:\n                temp = arr[m]\n                arr[m] = arr[z]\n                arr[z] = temp\n            z += 1\n        m += 1\n    return arr"}, {"role": "assistant", "content": "### Fundamental Principles\n\nThe given Python program implements the Selection Sort algorithm, which sorts an array by repeatedly finding the minimum element from the unsorted part and putting it at the beginning. The algorithm maintains two subarrays in a given array:\n\n1. The subarray which is already sorted.\n2. The remaining subarray which is unsorted.\n\nIn every iteration of the outer loop (controlled by `m`), the smallest element from the unsorted subarray is selected and swapped with the leftmost unsorted element, thereby growing the sorted subarray by one element.\n\n### Loop Invariant\n\nFor the inner loop (controlled by `z`), the loop invariant should describe the state of the array as the inner loop progresses. Specifically, after each iteration of the inner loop, the smallest element among `arr[m]` to `arr[z-1]` has been moved to position `arr[m]`.\n\nThus, the loop invariant can be stated as follows:\n\n- For the inner loop (controlled by `z`): \n  - `min_value = min(arr[m]->arr[z-1])`\n  \nHowever, since we are asked to write the loop invariant in the form `xxx_value = fun(arr[xxx]->arr[xxx])`, we adjust this slightly to reflect the correct indices and the action taken within the loop:\n\n- `min_value = min(arr[m+1]->arr[z])`\n\n### Final Answer\n\nTherefore, the final answer is:\n- `min_value = min(arr[m+1]->arr[z])`"}, {"role": "user", "content": "def selection_sort(arr):\n    m = 0\n    while m <= len(arr) - 1:\n        z = m + 1\n        while z <= len(arr) - 1:\n            if arr[z] < arr[m]:\n                temp = arr[m]\n                arr[m] = arr[z]\n                arr[z] = temp\n            z += 1\n        m += 1\n    return arr"}, {"role": "assistant", "content": "### Fundamental Principles\n\nThe provided Python program is an implementation of the Selection Sort algorithm. This algorithm works by dividing the input array into two parts: a sorted subarray and an unsorted subarray. In each iteration of the outer loop (controlled by `m`), the smallest element from the unsorted subarray is selected and placed at the beginning of the unsorted subarray, thus extending the sorted subarray by one element.\n\n### Loop Invariant\n\nTo determine the loop invariant for the inner loop (controlled by `z`), we need to ensure that after each iteration of the inner loop, the smallest element from the current range of the array (`arr[m]` to `arr[z-1]`) is correctly positioned at `arr[m]`. \n\nThe loop invariant for the inner loop should capture the fact that the smallest element from `arr[m]` to `arr[z-1]` is correctly placed at `arr[m]`.\n\n### Final Answer\n\nTherefore, the final answer is:\n- `min_value = min(arr[m]->arr[z-1])`"}]