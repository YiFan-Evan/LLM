[{"role": "system", "content": "In the following questions, I will provide a target Python program code. The code is a program containing a loop, and the purpose of the code is indicated by its function name. Please provide a loop invariant for the i-th iteration of the loop to prove the partial correctness of the program. The loop invariant should be written in the form 'xxx_value = fun(arr[xxx]->arr[xxx])'. (Please note that your answer should only contain statements in the specified format.)(For each problem, you need to first explain the fundamental principles involved in solving it, and then provide the answer to the problem in the form of \"Therefore, the final answer is: \".)"}, {"role": "user", "content": "def selection_sort(arr):\n    l = 0\n    while l < len(arr):\n        z = l + 1\n        while z < len(arr):\n            if arr[z] < arr[l]:\n                temp = arr[l]\n                arr[l] = arr[z]\n                arr[z] = temp\n            z += 1\n        l += 1\n    return arr"}, {"role": "assistant", "content": "### Fundamental Principles Involved\n\nThe given code implements the Selection Sort algorithm, which sorts an array by repeatedly finding the minimum element from the unsorted part and putting it at the beginning. The core idea behind selection sort is to divide the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list.\n\nInitially, the sorted sublist is empty, and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right.\n\n### Loop Invariant Explanation\n\nTo prove the partial correctness of the `selection_sort` function, we need to define a loop invariant for the outer while loop. The loop invariant should capture the state of the array after each iteration of the outer loop.\n\nFor the outer loop (`while l < len(arr)`):\n\n- **Loop Invariant:** After the i-th iteration of the outer loop, the first `l` elements of the array are sorted in non-decreasing order.\n- **Formal Statement:** `sorted_value = fun(arr[0]->arr[l-1])`, where `fun(arr[0]->arr[l-1])` means that the subarray `arr[0]` to `arr[l-1]` is sorted in non-decreasing order.\n\n### Answer\n\nTherefore, the final answer is:\n```\nsorted_value = fun(arr[0]->arr[l-1])\n```"}, {"role": "user", "content": "def selection_sort(arr):\n    l = -1\n    while l < len(arr) - 1:\n        l += 1\n        z = l + 1\n        while z < len(arr):\n            if arr[z] < arr[l]:\n                temp = arr[l]\n                arr[l] = arr[z]\n                arr[z] = temp\n            z += 1\n    return arr"}, {"role": "assistant", "content": "### Fundamental Principles Involved\n\nThe provided code implements the Selection Sort algorithm. The primary goal of selection sort is to sort an array by repeatedly finding the minimum element from the unsorted part and moving it to the beginning of the unsorted section.\n\nDuring each iteration of the outer loop, the algorithm selects the smallest element from the unsorted portion of the array and swaps it with the first unsorted element. This process effectively grows the sorted portion of the array one element at a time.\n\n### Loop Invariant Explanation\n\nFor the outer loop (`while l < len(arr) - 1`):\n\n- **Loop Invariant:** After the i-th iteration of the outer loop, the first `l+1` elements of the array are sorted in non-decreasing order.\n- **Formal Statement:** `sorted_value = fun(arr[0]->arr[l])`, where `fun(arr[0]->arr[l])` means that the subarray `arr[0]` to `arr[l]` is sorted in non-decreasing order.\n\n### Answer\n\nTherefore, the final answer is:\n```\nsorted_value = fun(arr[0]->arr[l])\n```"}]