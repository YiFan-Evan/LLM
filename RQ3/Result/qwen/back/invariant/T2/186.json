[{"role": "system", "content": "In the following questions, I will provide a target Python program code. The code is a program containing a loop, and the purpose of the code is indicated by its function name. Please provide a loop invariant for the i-th iteration of the loop to prove the partial correctness of the program. The loop invariant should be written in the form 'xxx_value = fun(arr[xxx]->arr[xxx])'. (Please note that your answer should only contain statements in the specified format.)(For each problem, you need to first explain the fundamental principles involved in solving it, and then provide the answer to the problem in the form of \"Therefore, the final answer is: \".)"}, {"role": "user", "content": "def selection_sort(arr):\n    g = 0\n    while g < len(arr):\n        z = g + 1\n        while z < len(arr):\n            if arr[z] < arr[g]:\n                temp = arr[g]\n                arr[g] = arr[z]\n                arr[z] = temp\n            z += 1\n        g += 1\n    return arr"}, {"role": "assistant", "content": "### Fundamental Principles Involved\n\nThe given code implements the Selection Sort algorithm, which works by repeatedly finding the minimum element from the unsorted part of the array and putting it at the beginning. This is done through nested loops where the outer loop (`g`) selects the current position in the array, and the inner loop (`z`) searches for the smallest element in the remaining unsorted part of the array.\n\nTo prove the partial correctness of this program, we need to establish a loop invariant for each loop that holds true before and after each iteration of the loop.\n\n### Loop Invariant for the Outer Loop\n\nFor the outer loop, a suitable loop invariant can be defined as follows:\n\n- **Loop Invariant for the Outer Loop:** At the start of each iteration of the outer loop (i.e., before the inner loop runs), the subarray `arr[0:g]` contains the smallest `g` elements from the original array, in sorted order.\n\nThis invariant holds because during each iteration of the outer loop, the inner loop ensures that the smallest element in the unsorted portion of the array is moved to the current position `g`. Hence, after each iteration of the outer loop, the first `g` elements are correctly sorted.\n\n### Loop Invariant for the Inner Loop\n\nFor the inner loop, we need to define an invariant that captures the state of the array as the inner loop progresses:\n\n- **Loop Invariant for the Inner Loop:** At the start of each iteration of the inner loop (i.e., before the comparison and potential swap occur), the subarray `arr[g+1:z]` contains elements that have not been compared with `arr[g]`.\n\nThis invariant holds because the inner loop iterates from `g+1` to the end of the array, comparing each element with `arr[g]` and swapping if necessary. Therefore, before each comparison, the elements between `g+1` and `z` have not yet been compared with `arr[g]`.\n\n### Final Answer\n\nTherefore, the final answer is:\n- **Outer Loop Invariant:** `sorted_value = fun(arr[0:g]->arr[0:g])` where `fun` represents the function that returns the subarray `arr[0:g]` being sorted.\n- **Inner Loop Invariant:** `uncompared_value = fun(arr[g+1:z]->arr[g+1:z])` where `fun` represents the function that returns the subarray `arr[g+1:z]` being uncompared with `arr[g]`.\n\nIn specific format:\n- **Outer Loop Invariant:** `sorted_value = fun(arr[0:g]->arr[0:g])`\n- **Inner Loop Invariant:** `uncompared_value = fun(arr[g+1:z]->arr[g+1:z])`"}, {"role": "user", "content": "def selection_sort(arr):\n    g = -1\n    while g < len(arr) - 1:\n        g += 1\n        z = g + 1\n        while z < len(arr):\n            if arr[z] < arr[g]:\n                temp = arr[g]\n                arr[g] = arr[z]\n                arr[z] = temp\n            z += 1\n    return arr"}, {"role": "assistant", "content": "### Fundamental Principles Involved\n\nThe provided code implements the Selection Sort algorithm. The algorithm works by dividing the array into two parts: a sorted part and an unsorted part. Initially, the sorted part is empty, and the unsorted part contains all the elements. In each iteration of the outer loop, the algorithm finds the smallest element in the unsorted part and moves it to the end of the sorted part.\n\nTo prove the partial correctness of this program, we need to establish loop invariants for both the outer and inner loops.\n\n### Loop Invariant for the Outer Loop\n\nThe outer loop iterates from `g = -1` to `len(arr) - 2`. At the start of each iteration of the outer loop, the first `g + 1` elements of the array are sorted and in their correct positions.\n\n- **Loop Invariant for the Outer Loop:** At the start of each iteration of the outer loop, the subarray `arr[0:g+1]` contains the smallest `g + 1` elements from the original array, sorted in non-decreasing order.\n\n### Loop Invariant for the Inner Loop\n\nThe inner loop iterates from `z = g + 1` to `len(arr) - 1`. During each iteration of the inner loop, the element at index `g` is compared with the elements from `g + 1` to `z - 1`, and the smallest element found so far is stored in `arr[g]`.\n\n- **Loop Invariant for the Inner Loop:** At the start of each iteration of the inner loop, the subarray `arr[g+1:z]` contains elements that have not been compared with `arr[g]`.\n\n### Final Answer\n\nTherefore, the final answer is:\n\n- **Outer Loop Invariant:** `sorted_value = fun(arr[0:g+1]->arr[0:g+1])`\n- **Inner Loop Invariant:** `uncompared_value = fun(arr[g+1:z]->arr[g+1:z])`\n\nWhere `fun` represents the function that returns the subarray in its current state. \n\nIn specific format:\n- **Outer Loop Invariant:** `sorted_value = fun(arr[0:g+1]->arr[0:g+1])`\n- **Inner Loop Invariant:** `uncompared_value = fun(arr[g+1:z]->arr[g+1:z])`"}]